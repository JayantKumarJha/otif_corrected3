# -*- coding: utf-8 -*-
"""Swiss_Powder_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11Y0GcaLqkIlquahzncTaLdbfjJH0llNZ
"""

import streamlit as st
import pandas as pd
import math
from datetime import datetime, timedelta
from io import BytesIO

st.set_page_config(page_title="Vial Scheduler", layout="wide")
st.title("üß™ Powder/Vial Scheduler")

uploaded_file = st.file_uploader("üì• Upload Vial Excel File", type=["xlsx"])

if uploaded_file:
    df = pd.read_excel(uploaded_file)

    st.sidebar.header("‚öôÔ∏è Manual Settings")

    # Max runtime override
    MAX_TIME = st.sidebar.number_input("üîß Max Runtime per Day (mins)", min_value=1, max_value=1440, value=1140)
    CHANGEOVER = 180

    # Speed override for vial sizes
    st.sidebar.subheader("‚úèÔ∏è Speed Override by Vial Pack Size (e.g., 2m, 2t, etc.)")
    default_speed_vials = {
        "1m": 200, "1t": 200, "2m": 200, "2t": 200, "3m": 170, "3t": 170,
        "5t": 110, "5m": 100, "10t": 110, "10m": 93, "20m": 60, "20t": 60,
        "30m": 50, "30t": 50, "50m": 60, "50t": 50
    }

    unique_sizes = sorted(df["Pack Size(ml)"].dropna().unique())
    override_speed = {}

    for size in unique_sizes:
        default = default_speed_vials.get(str(size).lower(), 50)
        override_speed[size] = st.sidebar.number_input(f"Speed for {size}", 1, 1000, value=default)

    def get_speed(row):
        if not pd.isna(row.get("Speed")):
            return row["Speed"]
        return override_speed.get(row["Pack Size(ml)"], 50)

    df["Speed"] = df.apply(get_speed, axis=1)

    df["RM Date"] = pd.to_datetime(df["Tentative Arrival Date of RM"])
    df["PM Date"] = pd.to_datetime(df["Tentative Arrival Date of PM"])
    today = datetime.today().date()
    df["Earliest Available Date"] = df[["RM Date", "PM Date"]].max(axis=1).dt.date
    df["Earliest Available Date"] = df["Earliest Available Date"].apply(lambda x: x if x > today else today)

    # Expand into batches
    batches, total_demand, batch_counter = [], 0, 0

    for _, row in df.iterrows():
        demand, batch_size, speed = row["Demand Quantity"], row["Batch Size"], row["Speed"]
        product, available_date = row["Product name"], row["Earliest Available Date"]

        num_batches = math.ceil(demand / batch_size)
        total_demand += demand

        for i in range(num_batches):
            actual_batch_size = batch_size if i < num_batches - 1 else demand - batch_size * (num_batches - 1)
            duration = actual_batch_size / speed
            batches.append({
                "Batch ID": batch_counter,
                "Product": product,
                "Batch Size": int(actual_batch_size),
                "Speed": speed,
                "Duration": duration,
                "Available Date": available_date
            })
            batch_counter += 1

    # Remove oversized batches
    fit_batches, too_big_batches = [], []
    for b in batches:
        if b["Duration"] + CHANGEOVER > MAX_TIME:
            too_big_batches.append(b)
        else:
            fit_batches.append(b)

    if too_big_batches:
        st.warning("‚ö†Ô∏è The following batches are too large to fit in a day and were skipped:")
        for b in too_big_batches:
            st.text(f"‚ùå {b['Product']} ‚Äî Duration: {b['Duration']:.2f} min")

    batches = fit_batches
    batches.sort(key=lambda b: b["Duration"], reverse=True)

    # Scheduling
    START_MIN = 8 * 60 + 30  # 08:30
    schedule = []
    unscheduled = batches.copy()
    schedule_date = today + timedelta(days=1)

    def min_to_time(minutes):
        h = int(minutes // 60)
        m = int(minutes % 60)
        return f"{h:02}:{m:02}"

    while unscheduled:
        current_time = START_MIN
        time_used = 0
        day_plan = []
        used_today = []

        todays_batches = [b for b in unscheduled if b["Available Date"] <= schedule_date]

        for idx, batch in enumerate(todays_batches):
            total_time = batch["Duration"]
            if used_today:
                total_time += CHANGEOVER

            if time_used + total_time <= MAX_TIME:
                if used_today:
                    # Add changeover only between batches (not at start of day)
                    day_plan.append({
                        "Date": schedule_date.strftime("%Y-%m-%d"),
                        "Stage": "Changeover",
                        "Product": "",
                        "Start": min_to_time(current_time),
                        "End": min_to_time(current_time + CHANGEOVER),
                        "Units Produced": 0
                    })
                    current_time += CHANGEOVER
                    time_used += CHANGEOVER

                # Add batch
                end_time = current_time + batch["Duration"]
                units = round(batch["Duration"] * batch["Speed"])
                day_plan.append({
                    "Date": schedule_date.strftime("%Y-%m-%d"),
                    "Stage": "Produce",
                    "Product": batch["Product"],
                    "Start": min_to_time(current_time),
                    "End": min_to_time(end_time),
                    "Units Produced": units
                })
                current_time = end_time
                time_used += batch["Duration"]
                used_today.append(batch)

        if not used_today:
            schedule_date += timedelta(days=1)
            continue

        used_ids = {b["Batch ID"] for b in used_today}
        unscheduled = [b for b in unscheduled if b["Batch ID"] not in used_ids]
        schedule.extend(day_plan)
        schedule_date += timedelta(days=1)

    # Output
    schedule_df = pd.DataFrame(schedule)
    output = BytesIO()
    schedule_df.to_excel(output, index=False, engine="openpyxl")
    output.seek(0)

    st.success("‚úÖ Vial Schedule Ready")
    st.download_button("üì• Download Schedule", output, "Vial_Schedule.xlsx")

    # Summary
    st.markdown("---")
    st.subheader("üìå Summary")
    st.markdown(f"üì¶ **Total Demand:** `{total_demand:,}` units")
    st.markdown(f"‚úÖ **Scheduled Units:** `{int(schedule_df['Units Produced'].sum()):,}`")
    st.markdown(f"üîÅ **Total Batches:** `{len(schedule_df[schedule_df['Stage'] == 'Produce'])}`")
    st.markdown(f"üìÖ **Production Days Used:** `{schedule_df['Date'].nunique()}`")