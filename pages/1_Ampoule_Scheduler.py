# -*- coding: utf-8 -*-
"""swiss_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19bbIbC7Sijk1fFTEz6htGRkDqf0NLmny
"""

import streamlit as st
import pandas as pd
import math
from datetime import datetime, timedelta
from io import BytesIO

st.set_page_config(page_title="Ampoule Scheduler", layout="wide")
st.title("üíâ Ampoule Line Scheduler")

# -------------------------------
# SIDEBAR CONFIGURATION SECTION
# -------------------------------
st.sidebar.header("‚öôÔ∏è Manual Settings")

# ‚úÖ Max runtime override
MAX_TIME = st.sidebar.number_input("üîß Max Runtime per Day (mins)", min_value=1, max_value=1440, value=1140)
CHANGEOVER = 180

# ‚úÖ Ampoule pack sizes (predefined)
st.sidebar.subheader("‚úèÔ∏è Speed Override by Pack Size (ml)")
default_speed_ampoule = {1: 200, 2: 200, 3: 170, 5: 170, 10: 115}
standard_sizes = [1, 2, 3, 5, 10]
override_speed = {}

for size in standard_sizes:
    default = default_speed_ampoule.get(size, 100)
    override_speed[size] = st.sidebar.number_input(
        f"Speed for {size}ml", min_value=1, max_value=1000, value=default
    )

# -------------------------------
# FILE UPLOAD AND PROCESSING
# -------------------------------
uploaded_file = st.file_uploader("üì• Upload Ampoule Excel File", type=["xlsx"])

if uploaded_file:
    df = pd.read_excel(uploaded_file)

    # ‚úÖ Assign speed using override or "Speed" column
    def get_speed(row):
        if not pd.isna(row.get("Speed")):
            return row["Speed"]
        return override_speed.get(row["Pack Size(ml)"], 100)

    df["Speed"] = df.apply(get_speed, axis=1)

    # ‚úÖ Parse dates
    df["RM Date"] = pd.to_datetime(df["Tentative Arrival Date of RM"])
    df["PM Date"] = pd.to_datetime(df["Tentative Arrival Date of PM"])
    today = datetime.today().date()
    df["Earliest Available Date"] = df[["RM Date", "PM Date"]].max(axis=1).dt.date
    df["Earliest Available Date"] = df["Earliest Available Date"].apply(lambda x: x if x > today else today)

    # ‚úÖ Expand into batches
    batches, total_demand, batch_counter = [], 0, 0

    for _, row in df.iterrows():
        demand = row["Demand Quantity"]
        batch_size = row["Batch Size"]
        speed = row["Speed"]
        product = row["Product name"]
        available_date = row["Earliest Available Date"]

        num_batches = math.ceil(demand / batch_size)
        total_demand += demand

        for i in range(num_batches):
            actual_batch_size = batch_size if i < num_batches - 1 else demand - batch_size * (num_batches - 1)
            duration = actual_batch_size / speed
            batches.append({
                "Batch ID": batch_counter,
                "Product": product,
                "Batch Size": int(actual_batch_size),
                "Speed": speed,
                "Duration": duration,
                "Available Date": available_date
            })
            batch_counter += 1

    # ‚úÖ Filter out batches that don't fit in a day
    fit_batches, too_big_batches = [], []
    for b in batches:
        if b["Duration"] + CHANGEOVER > MAX_TIME:
            too_big_batches.append(b)
        else:
            fit_batches.append(b)

    if too_big_batches:
        st.warning("‚ö†Ô∏è Some batches were too large to fit and were skipped:")
        for b in too_big_batches:
            st.text(f"‚ùå {b['Product']} ‚Äî Duration: {b['Duration']:.2f} min")

    batches = fit_batches
    batches.sort(key=lambda b: b["Duration"], reverse=True)

    # ‚úÖ Scheduling logic
    START_MIN = 8 * 60 + 30  # 08:30 AM
    schedule = []
    unscheduled = batches.copy()
    schedule_date = today + timedelta(days=1)

    def min_to_time(minutes):
        h = int(minutes // 60)
        m = int(minutes % 60)
        return f"{h:02}:{m:02}"

    while unscheduled:
        current_time = START_MIN
        time_used = 0
        day_plan = []
        used_today = []

        todays_batches = [b for b in unscheduled if b["Available Date"] <= schedule_date]

        for i, batch in enumerate(todays_batches):
            total_time = batch["Duration"]

            # Add changeover ONLY if this is not the first batch of the day
            if used_today:
                total_time += CHANGEOVER

            if time_used + total_time <= MAX_TIME:
                # If not first batch, add changeover
                if used_today:
                    day_plan.append({
                        "Date": schedule_date.strftime("%Y-%m-%d"),
                        "Stage": "Changeover",
                        "Product": "",
                        "Start": min_to_time(current_time),
                        "End": min_to_time(current_time + CHANGEOVER),
                        "Units Produced": 0
                    })
                    current_time += CHANGEOVER
                    time_used += CHANGEOVER

                # Add production batch
                end_time = current_time + batch["Duration"]
                units = round(batch["Duration"] * batch["Speed"])
                day_plan.append({
                    "Date": schedule_date.strftime("%Y-%m-%d"),
                    "Stage": "Produce",
                    "Product": batch["Product"],
                    "Start": min_to_time(current_time),
                    "End": min_to_time(end_time),
                    "Units Produced": units
                })
                current_time = end_time
                time_used += batch["Duration"]
                used_today.append(batch)

        if not used_today:
            schedule_date += timedelta(days=1)
            continue

        used_ids = {b["Batch ID"] for b in used_today}
        unscheduled = [b for b in unscheduled if b["Batch ID"] not in used_ids]
        schedule.extend(day_plan)
        schedule_date += timedelta(days=1)

    # ‚úÖ Output
    schedule_df = pd.DataFrame(schedule)
    output = BytesIO()
    schedule_df.to_excel(output, index=False, engine="openpyxl")
    output.seek(0)

    st.success("‚úÖ Ampoule Schedule Ready!")
    st.download_button("üì• Download Schedule", output, "Ampoule_Schedule.xlsx")

    # ‚úÖ Summary
    st.markdown("---")
    st.subheader("üìå Summary")
    st.markdown(f"üì¶ **Total Demand:** `{total_demand:,}` units")
    st.markdown(f"‚úÖ **Scheduled Units:** `{int(schedule_df['Units Produced'].sum()):,}`")
    st.markdown(f"üîÅ **Total Batches:** `{len(schedule_df[schedule_df['Stage'] == 'Produce'])}`")
    st.markdown(f"üìÖ **Production Days Used:** `{schedule_df['Date'].nunique()}`")