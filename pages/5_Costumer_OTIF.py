# -*- coding: utf-8 -*-
"""5_Costumer_OTIF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NG8GK18w24yr-jtFuNkrLeS41rl0pmd3
"""

# pages/Customer_OTIF.py
# -------------------------------------------------------------
# Customer OTIF Analysis â€” Streamlit
# - Columns used exactly (with dots): COUNTRY, GENERIC NAME, ORDER NO,
#   ORDER QTY., DISPATCH QTY., EXPECTED DISPATCH DATE, ACTUAL DISPATCH DATE
# - Drops any row missing any of these 7 columns
# - Line-level checks (per ORDER NO + GENERIC NAME):
#     Line In-Full: DISPATCH QTY. >= 95% of ORDER QTY.
#     Line On-Time: ACTUAL DISPATCH DATE <= EXPECTED DISPATCH DATE
#   Order OTIF = 1 only if all lines are In-Full and On-Time
# - Month bucketing = last ACTUAL DISPATCH DATE per order (completion date)
# - Shows only Yearly OTIF (order-level mean), plus total orders
# - PDF export of ALL failed orders grouped by COUNTRY (descending)
# -------------------------------------------------------------

import io
import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px

# Try to import reportlab for PDF generation; show helpful message if not installed
try:
    from reportlab.lib.pagesizes import A4
    from reportlab.pdfgen import canvas
    from reportlab.lib.units import mm
    REPORTLAB_OK = True
except Exception:
    REPORTLAB_OK = False

st.set_page_config(page_title="Customer OTIF Analysis", page_icon="ðŸšš", layout="wide")
st.title("ðŸšš Customer OTIF (On-Time In-Full) â€” Order Level")
st.caption(
    "Upload your order/dispatch Excel â†’ weâ€™ll clean it, drop incomplete rows, compute OTIF at the order level "
    "(an order fails if any line is late or not in full), then show monthly performance. "
    "Month bucketing uses the orderâ€™s last Actual Dispatch Date."
)

# --------------------------- CONSTANTS ---------------------------
REQ = [
    "COUNTRY",
    "GENERIC NAME",
    "ORDER NO",
    "ORDER QTY.",
    "DISPATCH QTY.",
    "EXPECTED DISPATCH DATE",
    "ACTUAL DISPATCH DATE",
]

# --------------------------- HELPERS ---------------------------
def clean_columns_preserve(df: pd.DataFrame) -> pd.DataFrame:
    """Trim whitespace / NBSP in column names, but keep case and punctuation (keep the dots)."""
    df = df.copy()
    df.columns = (
        df.columns
        .str.replace("\u00A0", " ", regex=False)  # NBSP -> space
        .str.strip()
        .str.replace(r"\s+", " ", regex=True)     # collapse internal spaces
    )
    if df.columns.duplicated().any():
        df = df.loc[:, ~df.columns.duplicated()]
    return df

def ensure_required(df: pd.DataFrame):
    missing = [c for c in REQ if c not in df.columns]
    if missing:
        raise ValueError(f"Input file is missing required columns: {missing}")

def to_float_series(s: pd.Series) -> pd.Series:
    """Robust float conversion: removes commas/spaces, converts (1,234) -> -1234, etc."""
    if s.dtype.kind in "biufc":
        return s.astype(float)
    s = s.astype(str).str.strip()
    # negative in parentheses â†’ -value
    s = s.str.replace(r"^\((.*)\)$", r"-\1", regex=True)
    # remove commas and spaces
    s = s.str.replace(",", "", regex=False).str.replace(" ", "", regex=False)
    return pd.to_numeric(s, errors="coerce").astype(float)

def to_datetime_naive(s: pd.Series) -> pd.Series:
    """
    Parse to datetime safely:
      1) parse with utc=True to avoid tz-mixing,
      2) convert to naive (no timezone),
      3) dayfirst=True as many sheets are dd-mm-yyyy.
    """
    dt = pd.to_datetime(s, errors="coerce", dayfirst=True, utc=True)
    # drop timezone â†’ naive
    return dt.dt.tz_convert(None)

def load_and_clean(file) -> pd.DataFrame:
    df = pd.read_excel(file)
    df = clean_columns_preserve(df)
    ensure_required(df)

    # Keep only required columns (in the same order)
    df = df[REQ].copy()

    # Convert types
    df["ORDER QTY."] = to_float_series(df["ORDER QTY."])
    df["DISPATCH QTY."] = to_float_series(df["DISPATCH QTY."])
    df["EXPECTED DISPATCH DATE"] = to_datetime_naive(df["EXPECTED DISPATCH DATE"])
    df["ACTUAL DISPATCH DATE"]  = to_datetime_naive(df["ACTUAL DISPATCH DATE"])

    # Drop any row that has a missing in ANY of the 7 required columns
    df = df.dropna(subset=REQ).copy()

    # Also guard against â€œempty-stringâ€ style values in text columns
    for c in ["COUNTRY", "GENERIC NAME", "ORDER NO"]:
        df[c] = df[c].astype(str).str.strip()
    df = df[(df["COUNTRY"] != "") & (df["GENERIC NAME"] != "") & (df["ORDER NO"] != "")]
    return df.reset_index(drop=True)

def compute_order_metrics(df: pd.DataFrame):
    """
    Line-level = (ORDER NO, GENERIC NAME)
      Line In-Full: sum(DISPATCH QTY.) >= 95% * sum(ORDER QTY.)
      Line On-Time: max(ACTUAL DISPATCH DATE) <= max(EXPECTED DISPATCH DATE)
    Order-level:
      IN_FULL = min(Line In-Full), ON_TIME = min(Line On-Time)
      OTIF = IN_FULL * ON_TIME
      COMPLETION DATE (for month bucketing) = last ACTUAL DISPATCH DATE in the order
    """
    # Aggregate lines (combine duplicate lines for same ORDER NO + GENERIC NAME)
    lines = (
        df.groupby(["ORDER NO", "GENERIC NAME"], as_index=False)
          .agg({
              "ORDER QTY.": "sum",
              "DISPATCH QTY.": "sum",
              "EXPECTED DISPATCH DATE": "max",
              "ACTUAL DISPATCH DATE": "max",
              "COUNTRY": "first",  # keep an attribute for grouping later
          })
    )

    lines["Line_InFull"] = (lines["DISPATCH QTY."] >= 0.95 * lines["ORDER QTY."]).astype(int)
    lines["Line_OnTime"] = (lines["ACTUAL DISPATCH DATE"] <= lines["EXPECTED DISPATCH DATE"]).astype(int)

    # Order-level metrics
    order_status = (
        lines.groupby("ORDER NO")
             .agg(
                 Order_InFull=("Line_InFull", "min"),
                 Order_OnTime=("Line_OnTime", "min"),
                 Country=("COUNTRY", "first"),
                 Last_Actual_Dispatch=("ACTUAL DISPATCH DATE", "max"),
             )
             .reset_index()
    )
    order_status["OTIF"] = (order_status["Order_InFull"] * order_status["Order_OnTime"]).astype(int)

    # Date parts (month bucketing by last actual dispatch date)
    od = order_status.copy()
    od["Year"] = od["Last_Actual_Dispatch"].dt.year
    od["MonthNum"] = od["Last_Actual_Dispatch"].dt.month
    od["Month"] = od["Last_Actual_Dispatch"].dt.strftime("%b")

    return lines, od

def generate_failed_orders_pdf(breaches_df: pd.DataFrame, year: int) -> bytes:
    """
    Create a PDF listing ALL failed OTIF orders grouped by COUNTRY, descending by failures.
    For each COUNTRY, list (Date  Order No.) with Date = Last_Actual_Dispatch (dd-mm-yyyy).
    """
    if not REPORTLAB_OK:
        raise RuntimeError("reportlab not available")

    buf = io.BytesIO()
    width, height = A4
    c = canvas.Canvas(buf, pagesize=A4)
    margin_x = 20 * mm
    y = height - 20 * mm
    lh = 8 * mm

    # Title
    c.setFont("Helvetica-Bold", 16)
    c.drawString(margin_x, y, f"ALL OTIF FAILED ORDERS â€” {year}")
    y -= 12 * mm

    # Group by COUNTRY by count (desc)
    country_counts = (
        breaches_df.groupby("Country")
                   .size()
                   .reset_index(name="count")
                   .sort_values("count", ascending=False)
    )

    idx = 1
    for _, row in country_counts.iterrows():
        country = row["Country"]
        group = breaches_df[breaches_df["Country"] == country].sort_values("Last_Actual_Dispatch", ascending=False)

        # New page if needed
        if y < 40 * mm:
            c.showPage()
            y = height - 20 * mm
            c.setFont("Helvetica-Bold", 16)
            c.drawString(margin_x, y, f"ALL OTIF FAILED ORDERS â€” {year} (cont.)")
            y -= 12 * mm

        c.setFont("Helvetica-Bold", 12)
        c.drawString(margin_x, y, f"{idx}. {country}  (Failures: {len(group)})")
        y -= lh

        c.setFont("Helvetica", 10)
        for _, r in group.iterrows():
            date_str = r["Last_Actual_Dispatch"].strftime("%d-%m-%Y") if pd.notna(r["Last_Actual_Dispatch"]) else ""
            order_no = str(r["ORDER NO"])
            line_text = f"    {date_str}    {order_no}"
            c.drawString(margin_x + 6 * mm, y, line_text)
            y -= 6 * mm
            if y < 25 * mm:
                c.showPage()
                y = height - 20 * mm
                c.setFont("Helvetica", 10)
        y -= 4 * mm
        idx += 1

    c.save()
    buf.seek(0)
    return buf.getvalue()

# --------------------------- UI ---------------------------
data_file = st.file_uploader("ðŸ“¤ Upload Customer OTIF Excel (single sheet)", type=["xlsx", "xls"])
if not data_file:
    st.info("Expected columns: " + ", ".join(REQ))
    st.stop()

# Load & clean
try:
    df = load_and_clean(data_file)
except Exception as e:
    st.error(f"âŒ Processing error: {e}")
    st.stop()

if df.empty:
    st.warning("No rows remain after cleaning/dropping missing values.")
    st.stop()

# Compute metrics
lines, orders = compute_order_metrics(df)

# Year selector
years = sorted(orders["Year"].dropna().astype(int).unique().tolist())
if not years:
    st.error("No valid years found in ACTUAL DISPATCH DATE.")
    st.stop()

selected_year = st.selectbox("ðŸ“… Select Year", years, index=len(years)-1)
orders_year = orders[orders["Year"] == selected_year].copy()

# Monthly summary
monthly = (
    orders_year.groupby(["MonthNum", "Month"], as_index=False)
               .agg(
                   Avg_OTIF=("OTIF", "mean"),
                   Total_Orders=("ORDER NO", "count"),
               )
               .sort_values("MonthNum")
)

# KPIs â€” only yearly order-level OTIF + total orders (to match your vendor-page change)
k1, k2 = st.columns(2)
k1.metric("OTIF (Yearly order-level mean)", f"{(orders_year['OTIF'].mean()*100):.1f}%")
k2.metric("Total Orders (Year)", int(orders_year.shape[0]))

# Chart
st.subheader("ðŸ“Š Monthly OTIF (Selected Year)")
if monthly.empty:
    st.info("No orders for the selected year.")
else:
    month_order = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
    present = [m for m in month_order if m in monthly["Month"].tolist()]
    fig = px.bar(
        monthly,
        x="Month",
        y="Avg_OTIF",
        category_orders={"Month": present},
        text=monthly["Avg_OTIF"].map(lambda v: f"{v*100:.1f}%"),
        labels={"Month": "Month", "Avg_OTIF": "Average OTIF"},
        height=420
    )
    fig.update_traces(textposition="outside")
    fig.update_yaxes(range=[0, 1], tickformat=".0%")
    fig.update_layout(margin=dict(l=20, r=20, t=40, b=20))
    st.plotly_chart(fig, use_container_width=True)

# Monthly table
with st.expander("ðŸ“„ Monthly Summary Table"):
    tbl = monthly.copy()
    tbl["Avg_OTIF"] = (tbl["Avg_OTIF"] * 100).round(1)
    tbl = tbl.rename(columns={"MonthNum": "Month #", "Avg_OTIF": "Avg OTIF (%)"})
    st.dataframe(tbl, use_container_width=True)

# Failed orders + PDF
st.subheader("ðŸš¨ Countries with OTIF Breaches (Selected Year)")
breaches = orders_year[orders_year["OTIF"] == 0].copy()

if breaches.empty:
    st.success("No OTIF breaches in the selected year. ðŸŽ‰")
else:
    top_countries = (
        breaches.groupby("Country")
                .size()
                .reset_index(name="OTIF_Breaches")
                .sort_values("OTIF_Breaches", ascending=False)
                .head(10)
    )
    st.dataframe(top_countries, use_container_width=True)

    # PDF of ALL failed orders grouped by country
    if REPORTLAB_OK:
        try:
            pdf_bytes = generate_failed_orders_pdf(
                breaches[["ORDER NO", "Country", "Last_Actual_Dispatch"]], selected_year
            )
            st.download_button(
                "â¬‡ï¸ Download ALL Failed Orders (PDF)",
                data=pdf_bytes,
                file_name=f"Customer_OTIF_failed_orders_{selected_year}.pdf",
                mime="application/pdf"
            )
        except Exception as e:
            st.error(f"Error generating PDF: {e}")
            csv_bytes = breaches[["Country", "Last_Actual_Dispatch", "ORDER NO"]]\
                .sort_values(["Country", "Last_Actual_Dispatch"], ascending=[False, False])\
                .to_csv(index=False).encode("utf-8")
            st.download_button(
                "â¬‡ï¸ Download ALL Failed Orders (CSV fallback)",
                data=csv_bytes,
                file_name=f"Customer_OTIF_failed_orders_{selected_year}.csv",
                mime="text/csv"
            )
    else:
        st.warning("PDF export requires the `reportlab` package. Install with `pip install reportlab`.")
        csv_bytes = breaches[["Country", "Last_Actual_Dispatch", "ORDER NO"]]\
            .sort_values(["Country", "Last_Actual_Dispatch"], ascending=[False, False])\
            .to_csv(index=False).encode("utf-8")
        st.download_button(
            "â¬‡ï¸ Download ALL Failed Orders (CSV)",
            data=csv_bytes,
            file_name=f"Customer_OTIF_failed_orders_{selected_year}.csv",
            mime="text/csv"
        )

# Downloads
col1, col2 = st.columns([1.4, 1])
with col1:
    st.download_button(
        "â¬‡ï¸ Download Order-level Data (CSV)",
        data=orders_year.to_csv(index=False).encode("utf-8"),
        file_name=f"customer_orders_{selected_year}.csv",
        mime="text/csv",
    )
with col2:
    st.download_button(
        "â¬‡ï¸ Download Monthly Summary (CSV)",
        data=monthly.to_csv(index=False).encode("utf-8"),
        file_name=f"customer_monthly_otif_{selected_year}.csv",
        mime="text/csv",
    )

# Debug (optional)
with st.expander("ðŸ”Ž Debug / Sanity"):
    st.write("Rows after cleaning:", len(df))
    st.write("Orders in selected year:", len(orders_year))
    st.write("Yearly OTIF:", orders_year["OTIF"].mean())